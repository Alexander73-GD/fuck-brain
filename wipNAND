nand logic readable code (work in progress that I just want to save while it works)

[Code written on https://copy.sh/brainfuck/, the memory cells may be a bit more readable there but it doesn't really matter.
The memory cells are supposed to look like this:

255  A   B   C   0  ... 254
1st 2nd 3rd 4th 5th 6th ...

where A and B are the inputs of the NAND, C is the output, and the ordinal numbers are where the outputs are stored.
Ideally the first output will be stored in the 3rd position, the next one in the 4th, etc.]

[Default code asks user for the first two inputs, A and B. This can be changed as explained in the code*]

[By the way, these symbols, '>' and '<', are called 'single guillemet'. I will be abbreviating it as SG in the comments.]

FIRST NAND OPERATION (In this example: 1st⊕2nd)
->>>>>>>>>>>--+[-<+]->>
, (delete the comma to change the FIRST input to a 0 or change it for a plus sign to make it a 1)
[<+>->>>>>>>>>>+<<<<<<<<<<]>
, (delete the comma to change the SECOND input to a 0 or change it for a plus sign to make it a 1)
[<+>->>>>>>>>>>+<<<<<<<<<<]+<<[>[>->]]+[-<+]->>>+++[++[-->++]--
>>> (as many SG as the position where the output will be stored)
++[-<+]->>>-]

PREPARATION FOR NEXT OPERATION (In this example: 1st⊕3rd)
< (write TWO SG if you'll replace the input A or ONE SG if you'll replace B)
[-]
> (write TWO SG if you'll replace the input A or ONE SG if you'll replace B)
++[-->++]--
>>> (write as many SG as the number of the position where the new input is stored)
[++[--<++]--<+>
>>> (write as many SG as the number of the position where the new input is stored)
-]++[--<++]--<[+[-<+]-
>> (write ONE SG if you're replacing the value at A or TWO if you're replacing B)
+++[-->++]--
>>> (write as many SG as the number of the position where the new input is stored)
+++[--<++]--<-]+[-<+]-
>> (write ONE SG if you're replacing the value at A or TWO if you're replacing B)
--- THIS RIGHT HERE IS THE ONLY DIFFERENCE BEWTEEN THE FIRST OPERATION AND THE REST OF THEM AND I KNOW I COULD REMOVE I SOME WAY BUT I HAVEN'T FOUND IT**
++[-->++]--
>>> (write as many SG as the number of the position where the last output was stored AAAAAAAAAAAAAAAAAAAAAAA idk why but I mean the one at line 20 which btw should be the 3rd one)
---

SECOND NAND OPERATION (In this example: 1st⊕3rd=4th)
+[-<+]->>>+<<[>[>->]]+[-<+]->>>+++[++[-->++]--
>>>> (as many SG as the position where the output will be stored)
++[-<+]->>>-]

PREPARATION FOR NEXT OPERATION (In this example: 2nd⊕3rd)
<< (write TWO SG if you'll replace the input A or ONE SG if you'll replace B)
[-]
>> (write TWO SG if you'll replace the input A or ONE SG if you'll replace B)
++[-->++]--
>> (write as many SG as the number of the position where the new input is stored)
[++[--<++]--<+>
>> (write as many SG as the number of the position where the new input is stored)
-]++[--<++]--<[+[-<+]-
> (write ONE SG if you're replacing the value at A or TWO if you're replacing B)
+++[-->++]--
>> (write as many SG as the number of the position where the new input is stored)
+++[--<++]--<-]+[-<+]-
> (write ONE SG if you're replacing the value at A or TWO if you're replacing B)
**HERE IN THE FIRST PART THERE ARE THREE MINUS SIGNS WHICH I DON'T EXACTLY KNOW YET WHY ARE NOT NEEDED HERE NOR HOW TO FIX THAT
++[-->++]--
>>>> (write as many SG as the number of the position where the output will be stored AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)
---


THIRD NAND OPERATION (In this example: 2nd⊕3rd=5th)
+[-<+]->>>+<<[>[>->]]+[-<+]->>>+++[++[-->++]--
>>>>> (as many SG as the position where the output will be stored)
++[-<+]->>>-]

PREPARATION FOR NEXT OPERATION (In this example: 4th⊕5th)

First part: (In this example: 4th⊕3rd)
<< (write TWO SG if you'll replace the input A or ONE SG if you'll replace B)
[-]
>> (write TWO SG if you'll replace the input A or ONE SG if you'll replace B)
++[-->++]--
>>>> (write as many SG as the number of the position where the new input is stored)
[ ++[--<++]--<+>
>>>> (write as many SG as the number of the position where the new input is stored)
-]++[--<++]--<[+[-<+]-
> (write ONE SG if you're replacing the value at A or TWO if you're replacing B)
+++[-->++]--
>>>> (write as many SG as the number of the position where the new input is stored)
+++[--<++]--<-]+[-<+]-
> (write ONE SG if you're replacing the value at A or TWO if you're replacing B)
**HERE IN THE FIRST PART THERE ARE THREE MINUS SIGNS WHICH I DON'T EXACTLY KNOW YET WHY ARE NOT NEEDED HERE NOR HOW TO FIX THAT
++[-->++]--
>>>>> (write as many SG as the number of the position where the output will be stored AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)
---

Second part: (In this example: 4th⊕5th)
+[-<+]->>> extra bit to get to c

< (write TWO SG if you'll replace the input A or ONE SG if you'll replace B)
[-]
> (write TWO SG if you'll replace the input A or ONE SG if you'll replace B)
++[-->++]--
>>>>> (write as many SG as the number of the position where the new input is stored)
[ ++[--<++]--<+>
>>>>> (write as many SG as the number of the position where the new input is stored)
-]++[--<++]--<[+[-<+]-
>> (write ONE SG if you're replacing the value at A or TWO if you're replacing B)
+++[-->++]--
>>>>> (write as many SG as the number of the position where the new input is stored)
+++[--<++]--<-]+[-<+]-
>> (write ONE SG if you're replacing the value at A or TWO if you're replacing B)
**HERE IN THE FIRST PART THERE ARE THREE MINUS SIGNS WHICH I DON'T EXACTLY KNOW YET WHY ARE NOT NEEDED HERE NOR HOW TO FIX THAT
++[-->++]--
>>>>>> (write as many SG as the number of the position where the output will be stored AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)
---


FINAL NAND OPERATION AND OUTPUT RESULT (In this example: 4th⊕5th=6th)
+[-<+]->>>+<<[>[>->]]+[-<+]->>> (here in memory is the final 0 or 1)
>++++++++[<++++++>-]<. (and this just outputs it on screen)
